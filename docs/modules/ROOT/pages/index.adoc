= Quarkus - Openapi Generator
:extension-status: preview


WARNING: This is the instructions for the latest SNAPSHOT version (main branch). Please, see the https://github.com/quarkiverse/quarkus-openapi-generator/blob/1.0.1/README.md[latest **released** documentation] if you are looking for instructions.

WARNING: Version 2.x.x of this extension (`main` branch) supports Quarkus 3, and version 1.x.x (`quarkus2` branch) supports Quarkus 2.

Quarkus' extension for generation of https://quarkus.io/guides/rest-client[Rest Clients] based on OpenAPI specification files.

This extension is based on the https://openapi-generator.tech/[OpenAPI Generator Tool]. Please consider donation to help them maintain the
project: https://opencollective.com/openapi_generator/donate

This extension is for REST code generation for client side only. If you're looking for code generation for the server side, please take a look at the https://github.com/Apicurio/apicurio-codegen/tree/main/quarkus-extension[Quarkus Apicurio Extension].

**Want to contribute? Great!** We try to make it easy, and all contributions, even the smaller ones, are more than welcome. This includes bug reports, fixes, documentation, examples... But first, read https://github.com/quarkiverse/quarkus-openapi-generator/blob/main/CONTRIBUTING.md[this page].

[[getting-started]]
== Getting Started

include::getting-started.adoc[leveloffset=+1, opts=optional]

[[resteasy-support]]
== RESTEasy Reactive and Classic support

include::resteasy-support.adoc[leveloffset=+1, opts=optional]

[[returning-response-objects]]
== Returning `Response` objects

include::return-response-objects.adoc[leveloffset=+1, opts=optional]

[[logging]]
== Logging

include::logging.adoc[leveloffset=+1, opts=optional]

[[filter-openapi-spec-files]]
== Filtering OpenAPI Specification Files

include::filter-openapi-spec-files.adoc[leveloffset=+1, opts=optional]

[[authentication-support]]
== Authentication Support

include::authentication-support.adoc[leveloffset=+1, opts=optional]

[[autorization-token-prop]]
== Authorization Token Propagation

include::authorization-token-propagation.adoc[leveloffset=+1, opts=optional]

== Circuit Breaker

You can define the https://microprofile.io/project/eclipse/microprofile-fault-tolerance/spec/src/main/asciidoc/circuitbreaker.asciidoc[CircuitBreaker annotation from MicroProfile Fault Tolerance]
in your generated classes by setting the desired configuration in `application.properties`.

Let's say you have the following OpenAPI definition:

[source ,json]
----
{
  "openapi": "3.0.3",
  "info": {
    "title": "Simple API",
    "version": "1.0.0-SNAPSHOT"
  },
  "paths": {
    "/hello": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/bye": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  }
}
----

And you want to configure Circuit Breaker for the `/bye` endpoint, you can do it in the following way:

Add the https://quarkus.io/guides/smallrye-fault-tolerance[SmallRye Fault Tolerance extension] to your project's `pom.xml` file:

[source ,xml]
----
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-smallrye-fault-tolerance</artifactId>
</dependency>
----

Assuming your Open API spec file is in `src/main/openapi/simple-openapi.json`, add the following configuration to your `application.properties` file:

[source ,properties]
----
# Note that the file name must have only alphabetic characters or underscores (_).
quarkus.openapi-generator.codegen.spec.simple_openapi_json.base-package=org.acme.openapi.simple
# Enables the CircuitBreaker extension for the byeGet method from the DefaultApi class
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/enabled=true
----

With the above configuration, your Rest Clients will be created with a code similar to the following:

[source ,java]
----
package org.acme.openapi.simple.api;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.Map;

import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.MediaType;

@Path("")
@RegisterRestClient(configKey="simple-openapi_json")
public interface DefaultApi {

    @GET
    @Path("/bye")
    @Produces({ "text/plain" })
    @org.eclipse.microprofile.faulttolerance.CircuitBreaker
    public String byeGet();

    @GET
    @Path("/hello")
    @Produces({ "text/plain" })
    public String helloGet();

}
----

You can also override the default Circuit Breaker configuration by setting the properties
in `application.properties` https://quarkus.io/guides/smallrye-fault-tolerance#runtime-configuration[just as you would for a traditional MicroProfile application]:

[source ,properties]
----
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/failOn=java.lang.IllegalArgumentException,java.lang.NullPointerException
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/skipOn=java.lang.NumberFormatException
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/delay=33
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/delayUnit=MILLIS
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/requestVolumeThreshold=42
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/failureRatio=3.14
org.acme.openapi.simple.api.DefaultApi/byeGet/CircuitBreaker/successThreshold=22
----

See the module https://github.com/quarkiverse/quarkus-openapi-generator/tree/main/integration-tests/circuit-breaker[circuit-breaker] for an example of how to use this feature.

== Sending multipart/form-data

The rest client also supports request with mime-type multipart/form-data and, if the schema of the request body is known in advance, we can also automatically generate the models of the request
bodies.

NOTE: RESTEasy Reactive supports multipart/form-data https://quarkus.io/guides/rest-client-reactive#multipart[out of the box]. Thus, no additional dependency is required.

If you're using RESTEasy Classic, you need to add the following additional dependency to your `pom.xml`:

[source ,xml]
----
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-resteasy-multipart</artifactId>
</dependency>
----

For any multipart/form-data operation a model for the request body will be generated. Each part of the multipart is a field in this model that is annotated with the following annotations:

* `jakarta.ws.rs.FormParam`, where the value parameter denotes the part name,
* `PartType`, where the parameter is the jax-rs MediaType of the part (see below for details),
* and, if the part contains a file, `PartFilename`, with a generated default parameter that will be passed as the fileName sub-header in the
Content-Disposition header of the part.

For example, the model for a request that requires a file, a string and some complex object will look like this:

[source,java]
----
public class MultipartBody {

    @FormParam("file")
    @PartType(MediaType.APPLICATION_OCTET_STREAM)
    @PartFilename("fileFile")
    public File file;

    @FormParam("fileName")
    @PartType(MediaType.TEXT_PLAIN)
    public String fileName;

    @FormParam("someObject")
    @PartType(MediaType.APPLICATION_JSON)
    public MyComplexObject someObject;
}
----

Then in the client, when using RESTEasy Classic, the `org.jboss.resteasy.annotations.providers.multipart.MultipartForm` annotation is added in front of the multipart parameter:

[source,java]
----
@Path("/echo")
@RegisterRestClient(baseUri="http://my.endpoint.com/api/v1", configKey="multipart-requests_yml")
public interface MultipartService {

    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Produces(MediaType.TEXT_PLAIN)
    String sendMultipartData(@MultipartForm MultipartBody data);

}
----

When using RESTEasy Reactive, the `jakarta.ws.rs.BeanParam` annotation is added in front of the multipart parameter:

[source,java]
----
@Path("/echo")
@RegisterRestClient(baseUri="http://my.endpoint.com/api/v1", configKey="multipart-requests_yml")
public interface MultipartService {

  @POST
  @Consumes(MediaType.MULTIPART_FORM_DATA)
  @Produces(MediaType.TEXT_PLAIN)
  String sendMultipartData(@jakarta.ws.rs.BeanParam MultipartBody data);

}
----

See https://quarkus.io/guides/rest-client-multipart[Quarkus - Using the REST Client with Multipart] and
the https://docs.jboss.org/resteasy/docs/4.7.5.Final/userguide/html_single/index.html[RESTEasy JAX-RS specifications] for more details.

WARNING: `MultipartForm`  is deprecated when using RESTEasy Reactive.

`baseURI` value of `RegisterRestClient` annotation is extracted from the `servers` section of the file, if present. If not, it will be left empty and it is expected you set up the uri to be used in your configuration.

Importantly, if some multipart request bodies contain complex objects (i.e. non-primitives) you need to explicitly tell the Open API generator to create models for these objects by setting
the `skip-form-model` property corresponding to your spec in the `application.properties` to `false`, e.g.:

[source,properties]
----
quarkus.openapi-generator.codegen.spec.my_multipart_requests_yml.skip-form-model=false
----

See the module https://github.com/quarkiverse/quarkus-openapi-generator/tree/main/integration-tests/multipart-request[multipart-request] for an example of how to use this feature.

In case the default `PartFilename` annotation is not required, its generation can be disabled by setting the `generate-part-filename` property (globally or corresponding to your spec) in the `application.properties` to `false`, e.g.:

[source,properties]
----
quarkus.openapi-generator.codegen.spec.my_multipart_requests_yml.generate-part-filename=false
----

By default, the `PartFilename`'s value representing the filename is prefixed by the field name. This can be changed by setting the `use-field-name-in-part-filename` property (globally or corresponding to your spec) in the `application.properties` to `false`, e.g.:

[source,properties]
----
quarkus.openapi-generator.codegen.spec.my_multipart_requests_yml.use-field-name-in-part-filename=false
----

And in case the default `PartFilename` value is not suitable (e.g. a conversion service only allows/supports specific extensions), the value can be set by using the `part-filename-value` property (globally or corresponding to your spec) in the `application.properties`, e.g.:

[source,properties]
----
quarkus.openapi-generator.codegen.spec.my_first_multipart_requests_yml.part-filename-value=".pdf"
----

So for instance, by setting `part-filename-value` to `some.pdf` and `use-field-name-in-part-filename` to `false` the generated code will look like this:

[source,java]
----
public class MultipartBody {

  @FormParam("file")
  @PartType(MediaType.APPLICATION_OCTET_STREAM)
  @PartFilename("some.pdf")
  public File file;
}
----

And by setting only `part-filename-value` to `.pdf`, the generated code will look like this:

[source,java]
----
public class MultipartBody {

  @FormParam("file")
  @PartType(MediaType.APPLICATION_OCTET_STREAM)
  @PartFilename("file.pdf")
  public File file;
}
----

See the module https://github.com/quarkiverse/quarkus-openapi-generator/tree/main/integration-tests/part-filename[part-filename] for examples of how to use these features.

=== Default content-types according to OpenAPI Specification and limitations

The https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#special-considerations-for-multipart-content[OAS 3.0] specifies the following default content-types for a multipart:

* If the property is a primitive, or an array of primitive values, the default Content-Type is `text/plain`
* If the property is complex, or an array of complex values, the default Content-Type is `application/json`
* If the property is a `type: string` with `format: binary` or `format: base64` (aka a file object), the default Content-Type is `application/octet-stream`

A different content-type may be defined in your api spec, but this is not yet supported in the code generation. Also, this "annotation-oriented" approach of RestEasy (i.e. using `@MultipartForm` to
denote the multipart body parameter) does not seem to properly support the unmarshalling of arrays of the same type (e.g. array of files), in these cases it uses Content-Type equal
to `application/json`.

== Generating files via InputStream

Having the files in the `src/main/openapi` directory will generate the REST stubs by default. Alternatively, you can implement
the `io.quarkiverse.openapi.generator.deployment.codegen.OpenApiSpecInputProvider`
interface to provide a list of `InputStream`s of OpenAPI specification files. This is useful in scenarios where you want to dynamically generate the client code without having the target spec file
saved locally in your project.

See the example implementation https://github.com/quarkiverse/quarkus-openapi-generator/blob/main/integration-tests/generation-input/src/main/java/io/quarkiverse/openapi/generator/codegen/ClassPathPetstoreOpenApiSpecInputProvider.java[here]

== Skip Deprecated Attributes in Model classes

The domain objects are classes generated in the `model` package. These classes might have https://spec.openapis.org/oas/v3.1.0#fixed-fields-9[deprecated attributes] in the Open API specification
file. By default, these attributes are generated. You can fine tune this behavior if the deprecated attributes should not be generated.

Use the property key `<base_package>.model.MyClass.generateDeprecated=false` to disable the deprecated attributes in the given model. For example `org.acme.weather.Country.generatedDeprecated=false`.

== Skip Deprecated Operations in API classes

The client objects are classes generated in the `api` package. These classes might have https://spec.openapis.org/oas/v3.1.0#operation-object[deprecated operations] in the Open API specification
file. By default, these operations are generated. You can fine tune this behavior if the deprecated operations should not be generated.

Use the property key `<base_package>.api.MyClass.generateDeprecated=false` to disable the deprecated operations in the given API. For example `org.acme.openapi.simple.api.DefaultApi.generatedDeprecated=false`.

[source,java]
----
package org.acme.openapi.simple.api;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.Map;

import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.MediaType;

@Path("")
@RegisterRestClient(configKey="simple-openapi_json")
@RegisterProvider(org.test.Foo.class)
@RegisterProvider(org.test.Bar.class)
public interface DefaultApi {

    @GET
    @Path("/bye")
    @Produces({ "text/plain" })
    @org.eclipse.microprofile.faulttolerance.CircuitBreaker
    public String byeGet();
}
----

See the module `integration-tests/register-provider` for an example of how to use this feature.

== Skip OpenAPI schema validation

Use the property key `quarkus.openapi-generator.codegen.validateSpec=false` to disable validating the input specification file before code generation. By default, invalid specifications will result in an error.

== Type and import mappings

It's possible to remap types in the generated files. For example, instead of a `File` you can configure the code generator to use `InputStream` for all file upload parts of multipart request, or you could change all `UUID` types to `String`. You can configure this in your `application.properties` using the following configuration keys:

[%autowidth]
|===
|Description |Property Key |Example

|Type Mapping
|`quarkus.openapi-generator.codegen.spec.[filename].type-mappings.[oas_type]`
|`quarkus.openapi-generator.codegen.spec.my_spec_yml.type-mappings.File=InputStream` will use `InputStream` as type for all objects of the OAS File type.
|Import Mapping
|`quarkus.openapi-generator.codegen.spec.[filename].import-mappings.[type]`
|`quarkus.openapi-generator.codegen.spec.my_spec_yml.import-mappings.File=java.io.InputStream` will replace the default `import java.io.File` with `import java.io.InputStream`
|===

Note that these configuration properties are maps. For the type-mapping the keys are OAS data types and the values are Java types.

Another common example is needing `java.time.Instant` as type for date-time fields in your POJO classes. You can achieve with these settings:

[source,properties]
----
quarkus.openapi-generator.codegen.spec.my_spec_yml.type-mappings.DateTime=Instant
quarkus.openapi-generator.codegen.spec.my_spec_yml.import-mappings.Instant=java.time.Instant
----

It's also possible to only use a type mapping with a fully qualified name, for instance `quarkus.openapi-generator.codegen.spec.my_spec_yml.type-mappings.File=java.io.InputStream`. For more information and a list of all types see the OpenAPI generator documentation on https://openapi-generator.tech/docs/usage/#type-mappings-and-import-mappings[Type Mappings and Import Mappings].

See the module https://github.com/quarkiverse/quarkus-openapi-generator/tree/main/integration-tests/type-mapping[type-mapping] for an example of how to use this feature.

== Config key

By default, the `@RegisterRestClient` `configKey` property is the sanitized name of the file containing the OpenAPI spec. For example, if the file name is `petstore.json`, the `configKey` will be `petstore_json`:

[source,java]
----
/* omitted */
@RegisterRestClient(configKey="petstore_json")
public interface DefaultApi { /* omitted */ }
----

If you want to use a different configKey than the default one, you can set the `quarkus.openapi-generator.codegen.spec.petstore_json.[config-key]` property.

Using the `config-key` the extension allow you to define all allowed properties with `quarkus.openapi-generator.codegen.spec.[my_custom_config_key].*` prefix. For example:

[source,properties]
----
quarkus.openapi-generator.codegen.spec.petstore_json.config-key=petstore
quarkus.openapi-generator.codegen.spec.petstore.additional-api-type-annotations=@org.test.Foo
----

With it, you will have the following result:

[source,java]
----
/* omitted */
@RegisterRestClient(configKey="petstore")
@org.test.Foo
public interface DefaultApi { /* omitted */ }
----

NOTE: If you configure the property config-key, it will override the sanitized file name (will not consider the order of the configurations). For example, having the following configuration:

[source,properties]
----
quarkus.openapi-generator.codegen.spec.petstore_json.config-key=custom_config_key
quarkus.openapi-generator.codegen.spec.custom_config_key.additional-api-type-annotations=@org.test.Foo
quarkus.openapi-generator.codegen.spec.petstore_json.additional-api-type-annotations=@org.test.Bar
----

The generated code will be:

[source,java]
----
/* omitted */
@RegisterRestClient(configKey="custom_config_key")
@org.test.Foo
public interface DefaultApi { /* omitted */ }
----

== Template Customization

You have the option to swap out the https://github.com/quarkiverse/quarkus-openapi-generator/tree/main/deployment/src/main/resources/templates/libraries/microprofile[templates used by this extension] with your customized versions. To achieve this, place your custom templates under the `resources/templates` directory. It's crucial that the filename of each custom template matches that of the original template.

You can find an example of using customized templates in https://github.com/quarkiverse/quarkus-openapi-generator/tree/main/integration-tests/custom-templates[integration-tests/custom-templates].

=== icon:warning[1x,role=red] Important

While the option to replace templates exists, it's essential to exercise caution and consider this as a final resort. Prior to altering templates, exhaust all possibilities of achieving your goals through configuration settings. Modifying templates could have broader implications for the extension's functionality and may introduce complexities. Only resort to template replacement when configuration adjustments prove insufficient for your requirements.

Furthermore, be aware that customizing templates increases the risk of compatibility issues during future upgrades. Therefore, exercise discretion and weigh the benefits against the potential risks before opting for template customization.

== Known Limitations

These are the known limitations of this pre-release version:

* Only Jackson support

We will work in the next few releases to address these use cases, until there please provide feedback for the current state of this extension. We also love contributions icon:heart[1x,role=red].
